# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/Pympler-0.9/pympler/process.py
import logging
import threading
try:
    from thread import get_ident
except ImportError:
    from _thread import get_ident

from os import getpid
from subprocess import Popen, PIPE
from pympler.util.stringutils import pp
try:
    from resource import getpagesize as _getpagesize
except ImportError:
    _getpagesize = lambda : 4096

class _ProcessMemoryInfo(object):
    pagesize = _getpagesize()

    def __init__(self):
        self.pid = getpid()
        self.rss = 0
        self.vsz = 0
        self.pagefaults = 0
        self.os_specific = []
        self.data_segment = 0
        self.code_segment = 0
        self.shared_segment = 0
        self.stack_segment = 0
        self.available = self.update()

    def __repr__(self):
        return '<%s vsz=%d rss=%d>' % (self.__class__.__name__, self.vsz, self.rss)

    def update(self):
        return False

    def __sub__(self, other):
        diff = [('Resident set size (delta)', self.rss - other.rss), ('Virtual size (delta)', self.vsz - other.vsz)]
        return diff


ProcessMemoryInfo = _ProcessMemoryInfo

def is_available():
    return ProcessMemoryInfo().update()


class _ProcessMemoryInfoPS(_ProcessMemoryInfo):

    def update(self):
        try:
            p = Popen(['/bin/ps',
             '-p%s' % self.pid,
             '-o',
             'rss,vsz'], stdout=PIPE, stderr=PIPE)
        except OSError:
            pass
        else:
            s = p.communicate()[0].split()
            if p.returncode == 0 and len(s) >= 2:
                self.vsz = int(s[-1]) * 1024
                self.rss = int(s[-2]) * 1024
                return True

        return False


class _ProcessMemoryInfoProc(_ProcessMemoryInfo):
    key_map = {'VmPeak': 'Peak virtual memory size',
     'VmSize': 'Virtual memory size',
     'VmLck': 'Locked memory size',
     'VmHWM': 'Peak resident set size',
     'VmRSS': 'Resident set size',
     'VmStk': 'Size of stack segment',
     'VmData': 'Size of data segment',
     'VmExe': 'Size of code segment',
     'VmLib': 'Shared library code size',
     'VmPTE': 'Page table entries size'}

    def update(self):
        try:
            stat = open('/proc/self/stat')
            status = open('/proc/self/status')
        except IOError:
            return False

        stats = stat.read().split()
        self.vsz = int(stats[22])
        self.rss = int(stats[23]) * self.pagesize
        self.pagefaults = int(stats[11])
        for entry in status.readlines():
            try:
                key, value = entry.split(':', 1)
            except ValueError:
                continue

            value = value.strip()
            size_in_bytes = lambda x: int(x.split()[0]) * 1024
            if key == 'VmData':
                self.data_segment = size_in_bytes(value)
            elif key == 'VmExe':
                self.code_segment = size_in_bytes(value)
            elif key == 'VmLib':
                self.shared_segment = size_in_bytes(value)
            elif key == 'VmStk':
                self.stack_segment = size_in_bytes(value)
            key = self.key_map.get(key)
            if key:
                self.os_specific.append((key, pp(size_in_bytes(value))))

        stat.close()
        status.close()
        return True


try:
    from resource import getrusage, RUSAGE_SELF

    class _ProcessMemoryInfoResource(_ProcessMemoryInfo):

        def update(self):
            usage = getrusage(RUSAGE_SELF)
            self.rss = usage.ru_maxrss * 1024
            self.data_segment = usage.ru_idrss * 1024
            self.shared_segment = usage.ru_ixrss * 1024
            self.stack_segment = usage.ru_isrss * 1024
            self.vsz = self.data_segment + self.shared_segment + self.stack_segment
            self.pagefaults = usage.ru_majflt
            return self.rss != 0


    if _ProcessMemoryInfoProc().update():
        ProcessMemoryInfo = _ProcessMemoryInfoProc
    elif _ProcessMemoryInfoPS().update():
        ProcessMemoryInfo = _ProcessMemoryInfoPS
    elif _ProcessMemoryInfoResource().update():
        ProcessMemoryInfo = _ProcessMemoryInfoResource
except ImportError:
    try:
        from win32process import GetProcessMemoryInfo
        from win32api import GetCurrentProcess, GlobalMemoryStatusEx
    except ImportError:
        logging.warn('Please install pywin32 when using pympler on Windows.')
    else:

        class _ProcessMemoryInfoWin32(_ProcessMemoryInfo):

            def update(self):
                process_handle = GetCurrentProcess()
                meminfo = GetProcessMemoryInfo(process_handle)
                memstatus = GlobalMemoryStatusEx()
                self.vsz = memstatus['TotalVirtual'] - memstatus['AvailVirtual']
                self.rss = meminfo['WorkingSetSize']
                self.pagefaults = meminfo['PageFaultCount']
                return True


        ProcessMemoryInfo = _ProcessMemoryInfoWin32

class ThreadInfo(object):

    def __init__(self, thread):
        self.ident = thread.ident
        self.name = thread.name
        self.daemon = thread.daemon


def get_current_threads():
    return [ ThreadInfo(thread) for thread in threading.enumerate() ]


def get_current_thread_id():
    return get_ident()
