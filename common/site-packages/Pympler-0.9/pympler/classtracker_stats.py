# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/Pympler-0.9/pympler/classtracker_stats.py
import os
import sys
from pympler.util.compat import pickle
from copy import deepcopy
from pympler.util.stringutils import trunc, pp, pp_timestamp
from pympler.asizeof import Asized
__all__ = ['Stats', 'ConsoleStats', 'HtmlStats']

def _merge_asized(base, other, level=0):
    ref2key = lambda ref: ref.name.split(':')[0]
    base.size += other.size
    base.flat += other.flat
    if level > 0:
        base.name = ref2key(base)
    base.refs = list(base.refs)
    refs = {}
    for ref in base.refs:
        refs[ref2key(ref)] = ref

    for ref in other.refs:
        key = ref2key(ref)
        if key in refs:
            _merge_asized(refs[key], ref, level=level + 1)
        base.refs.append(deepcopy(ref))
        base.refs[-1].name = key


def _merge_objects(tref, merged, obj):
    size = None
    for timestamp, tsize in obj.snapshots:
        if timestamp == tref:
            size = tsize

    if size:
        _merge_asized(merged, size)
    return


def _format_trace(trace):
    lines = []
    for fname, lineno, func, src, _ in trace:
        if src:
            for line in src:
                lines.append('    ' + line.strip() + '\n')

        lines.append('  %s:%4d in %s\n' % (fname, lineno, func))

    return ''.join(lines)


class Stats(object):

    def __init__(self, tracker=None, filename=None, stream=None):
        if stream:
            self.stream = stream
        else:
            self.stream = sys.stdout
        self.tracker = tracker
        if tracker:
            self.index = tracker.index
            self.snapshots = tracker.snapshots
            self.history = tracker.history
        else:
            self.index = None
            self.snapshots = None
        self.sorted = []
        if filename:
            self.load_stats(filename)
        return

    def load_stats(self, fdump):
        if isinstance(fdump, type('')):
            fdump = open(fdump, 'rb')
        self.index = pickle.load(fdump)
        self.snapshots = pickle.load(fdump)
        self.sorted = []

    def dump_stats(self, fdump, close=True):
        if self.tracker:
            self.tracker.stop_periodic_snapshots()
        if isinstance(fdump, type('')):
            fdump = open(fdump, 'wb')
        pickle.dump(self.index, fdump, protocol=pickle.HIGHEST_PROTOCOL)
        pickle.dump(self.snapshots, fdump, protocol=pickle.HIGHEST_PROTOCOL)
        if close:
            fdump.close()

    def _init_sort(self):
        if not self.sorted:
            tmax = None
            maxsize = 0
            for snapshot in self.snapshots:
                if snapshot.tracked_total > maxsize:
                    tmax = snapshot.timestamp

            for key in list(self.index.keys()):
                for tobj in self.index[key]:
                    tobj.classname = key
                    tobj.size = tobj.get_max_size()
                    tobj.tsize = tobj.get_size_at_time(tmax)

                self.sorted.extend(self.index[key])

        return

    def sort_stats(self, *args):
        criteria = ('classname', 'tsize', 'birth', 'death', 'name', 'repr', 'size')
        if not set(criteria).issuperset(set(args)):
            raise ValueError('Invalid sort criteria')
        if not args:
            args = criteria

        def args_to_tuple(obj):
            keys = []
            for attr in args:
                attribute = getattr(obj, attr)
                if attr in ('tsize', 'size'):
                    attribute = -attribute
                keys.append(attribute)

            return tuple(keys)

        self._init_sort()
        self.sorted.sort(key=args_to_tuple)
        return self

    def reverse_order(self):
        self._init_sort()
        self.sorted.reverse()
        return self

    def annotate(self):
        for snapshot in self.snapshots:
            self.annotate_snapshot(snapshot)

    def annotate_snapshot(self, snapshot):
        if hasattr(snapshot, 'classes'):
            return
        else:
            snapshot.classes = {}
            for classname in list(self.index.keys()):
                total = 0
                active = 0
                merged = Asized(0, 0)
                for tobj in self.index[classname]:
                    _merge_objects(snapshot.timestamp, merged, tobj)
                    total += tobj.get_size_at_time(snapshot.timestamp)
                    if tobj.birth < snapshot.timestamp and (tobj.death is None or tobj.death > snapshot.timestamp):
                        active += 1

                try:
                    pct = total * 100.0 / snapshot.total
                except ZeroDivisionError:
                    pct = 0

                try:
                    avg = total / active
                except ZeroDivisionError:
                    avg = 0

                snapshot.classes[classname] = dict(sum=total, avg=avg, pct=pct, active=active)
                snapshot.classes[classname]['merged'] = merged

            return

    @property
    def tracked_classes(self):
        return sorted(list(self.index.keys()))


class ConsoleStats(Stats):

    def _print_refs(self, refs, total, prefix='    ', level=1, minsize=0, minpct=0.1):
        lrefs = list(refs)
        lrefs.sort(key=lambda x: x.size)
        lrefs.reverse()
        for ref in lrefs:
            if ref.size > minsize and ref.size * 100.0 / total > minpct:
                self.stream.write('%-50s %-14s %3d%% [%d]\n' % (trunc(prefix + str(ref.name), 50),
                 pp(ref.size),
                 int(ref.size * 100.0 / total),
                 level))
                self._print_refs(ref.refs, total, prefix=prefix + '  ', level=level + 1)

    def print_object(self, tobj):
        if tobj.death:
            self.stream.write('%-32s ( free )   %-35s\n' % (trunc(tobj.name, 32, left=1), trunc(tobj.repr, 35)))
        else:
            self.stream.write('%-32s 0x%08x %-35s\n' % (trunc(tobj.name, 32, left=1), tobj.id, trunc(tobj.repr, 35)))
        if tobj.trace:
            self.stream.write(_format_trace(tobj.trace))
        for timestamp, size in tobj.snapshots:
            self.stream.write('  %-30s %s\n' % (pp_timestamp(timestamp), pp(size.size)))
            self._print_refs(size.refs, size.size)

        if tobj.death is not None:
            self.stream.write('  %-30s finalize\n' % (pp_timestamp(tobj.death),))
        return

    def print_stats(self, clsname=None, limit=1.0):
        if self.tracker:
            self.tracker.stop_periodic_snapshots()
        if not self.sorted:
            self.sort_stats()
        _sorted = self.sorted
        if clsname:
            _sorted = [ to for to in _sorted if clsname in to.classname ]
        if limit < 1.0:
            limit = max(1, int(len(self.sorted) * limit))
        _sorted = _sorted[:int(limit)]
        for tobj in _sorted:
            self.print_object(tobj)

    def print_summary(self):
        classlist = self.tracked_classes
        fobj = self.stream
        fobj.write('---- SUMMARY ' + '-' * 66 + '\n')
        for snapshot in self.snapshots:
            self.annotate_snapshot(snapshot)
            fobj.write('%-35s %11s %12s %12s %5s\n' % (trunc(snapshot.desc, 35),
             'active',
             pp(snapshot.asizeof_total),
             'average',
             'pct'))
            for classname in classlist:
                info = snapshot.classes.get(classname)
                fobj.write('  %-33s %11d %12s %12s %4d%%\n' % (trunc(classname, 33),
                 info['active'],
                 pp(info['sum']),
                 pp(info['avg']),
                 info['pct']))

        fobj.write('-' * 79 + '\n')


class HtmlStats(Stats):
    style = '<style type="text/css">\n        table { width:100%; border:1px solid #000; border-spacing:0px; }\n        td, th { border:0px; }\n        div { width:200px; padding:10px; background-color:#FFEECC; }\n        #nb { border:0px; }\n        #tl { margin-top:5mm; margin-bottom:5mm; }\n        #p1 { padding-left: 5px; }\n        #p2 { padding-left: 50px; }\n        #p3 { padding-left: 100px; }\n        #p4 { padding-left: 150px; }\n        #p5 { padding-left: 200px; }\n        #p6 { padding-left: 210px; }\n        #p7 { padding-left: 220px; }\n        #hl { background-color:#FFFFCC; }\n        #r1 { background-color:#BBBBBB; }\n        #r2 { background-color:#CCCCCC; }\n        #r3 { background-color:#DDDDDD; }\n        #r4 { background-color:#EEEEEE; }\n        #r5,#r6,#r7 { background-color:#FFFFFF; }\n        #num { text-align:right; }\n    </style>\n    '
    nopylab_msg = '<div color="#FFCCCC">Could not generate %s chart!\n    Install <a href="http://matplotlib.sourceforge.net/">Matplotlib</a>\n    to generate charts.</div>\n'
    chart_tag = '<img src="%s">\n'
    header = '<html><head><title>%s</title>%s</head><body>\n'
    tableheader = '<table border="1">\n'
    tablefooter = '</table>\n'
    footer = '</body></html>\n'
    refrow = '<tr id="r%(level)d">\n        <td id="p%(level)d">%(name)s</td>\n        <td id="num">%(size)s</td>\n        <td id="num">%(pct)3.1f%%</td></tr>'

    def _print_refs(self, fobj, refs, total, level=1, minsize=0, minpct=0.1):
        lrefs = list(refs)
        lrefs.sort(key=lambda x: x.size)
        lrefs.reverse()
        if level == 1:
            fobj.write('<table>\n')
        for ref in lrefs:
            if ref.size > minsize and ref.size * 100.0 / total > minpct:
                data = dict(level=level, name=trunc(str(ref.name), 128), size=pp(ref.size), pct=ref.size * 100.0 / total)
                fobj.write(self.refrow % data)
                self._print_refs(fobj, ref.refs, total, level=level + 1)

        if level == 1:
            fobj.write('</table>\n')

    class_summary = '<p>%(cnt)d instances of %(cls)s were registered. The\n        average size is %(avg)s, the minimal size is %(min)s, the maximum size\n        is %(max)s.</p>\n'
    class_snapshot = '<h3>Snapshot: %(name)s, %(total)s occupied by instances\n        of class %(cls)s</h3>\n'

    def print_class_details(self, fname, classname):
        fobj = open(fname, 'w')
        fobj.write(self.header % (classname, self.style))
        fobj.write('<h1>%s</h1>\n' % classname)
        sizes = [ tobj.get_max_size() for tobj in self.index[classname] ]
        total = 0
        for s in sizes:
            total += s

        data = {'cnt': len(self.index[classname]),
         'cls': classname}
        data['avg'] = pp(total / len(sizes))
        data['max'] = pp(max(sizes))
        data['min'] = pp(min(sizes))
        fobj.write(self.class_summary % data)
        fobj.write(self.charts[classname])
        fobj.write('<h2>Coalesced Referents per Snapshot</h2>\n')
        for snapshot in self.snapshots:
            if classname in snapshot.classes:
                merged = snapshot.classes[classname]['merged']
                fobj.write(self.class_snapshot % {'name': snapshot.desc,
                 'cls': classname,
                 'total': pp(merged.size)})
                if merged.refs:
                    self._print_refs(fobj, merged.refs, merged.size)
                else:
                    fobj.write('<p>No per-referent sizes recorded.</p>\n')

        fobj.write('<h2>Instances</h2>\n')
        for tobj in self.index[classname]:
            fobj.write('<table id="tl" width="100%" rules="rows">\n')
            fobj.write('<tr><td id="hl" width="140px">Instance</td>' + '<td id="hl">%s at 0x%08x</td></tr>\n' % (tobj.name, tobj.id))
            if tobj.repr:
                fobj.write('<tr><td>Representation</td>' + '<td>%s&nbsp;</td></tr>\n' % tobj.repr)
            fobj.write('<tr><td>Lifetime</td><td>%s - %s</td></tr>\n' % (pp_timestamp(tobj.birth), pp_timestamp(tobj.death)))
            if tobj.trace:
                trace = '<pre>%s</pre>' % _format_trace(tobj.trace)
                fobj.write('<tr><td>Instantiation</td><td>%s</td></tr>\n' % trace)
            for timestamp, size in tobj.snapshots:
                fobj.write('<tr><td>%s</td>' % pp_timestamp(timestamp))
                if not size.refs:
                    fobj.write('<td>%s</td></tr>\n' % pp(size.size))
                fobj.write('<td>%s' % pp(size.size))
                self._print_refs(fobj, size.refs, size.size)
                fobj.write('</td></tr>\n')

            fobj.write('</table>\n')

        fobj.write(self.footer)
        fobj.close()

    snapshot_cls_header = '<tr>\n        <th id="hl">Class</th>\n        <th id="hl" align="right">Instance #</th>\n        <th id="hl" align="right">Total</th>\n        <th id="hl" align="right">Average size</th>\n        <th id="hl" align="right">Share</th></tr>\n'
    snapshot_cls = '<tr>\n        <td>%(cls)s</td>\n        <td align="right">%(active)d</td>\n        <td align="right">%(sum)s</td>\n        <td align="right">%(avg)s</td>\n        <td align="right">%(pct)3.2f%%</td></tr>\n'
    snapshot_summary = '<p>Total virtual memory assigned to the program\n        at that time was %(sys)s, which includes %(overhead)s profiling\n        overhead. The ClassTracker tracked %(tracked)s in total. The measurable\n        objects including code objects but excluding overhead have a total size\n        of %(asizeof)s.</p>\n'

    def relative_path(self, filepath, basepath=None):
        if basepath is None:
            basepath = self.basedir
        if not basepath:
            return filepath
        else:
            if filepath.startswith(basepath):
                filepath = filepath[len(basepath):]
            if filepath and filepath[0] == os.sep:
                filepath = filepath[1:]
            return filepath

    def create_title_page(self, filename, title=''):
        fobj = open(filename, 'w')
        fobj.write(self.header % (title, self.style))
        fobj.write('<h1>%s</h1>\n' % title)
        fobj.write('<h2>Memory distribution over time</h2>\n')
        fobj.write(self.charts['snapshots'])
        fobj.write('<h2>Snapshots statistics</h2>\n')
        fobj.write('<table id="nb">\n')
        classlist = list(self.index.keys())
        classlist.sort()
        for snapshot in self.snapshots:
            fobj.write('<tr><td>\n')
            fobj.write('<table id="tl" rules="rows">\n')
            fobj.write('<h3>%s snapshot at %s</h3>\n' % (snapshot.desc or 'Untitled', pp_timestamp(snapshot.timestamp)))
            data = {}
            data['sys'] = pp(snapshot.system_total.vsz)
            data['tracked'] = pp(snapshot.tracked_total)
            data['asizeof'] = pp(snapshot.asizeof_total)
            data['overhead'] = pp(getattr(snapshot, 'overhead', 0))
            fobj.write(self.snapshot_summary % data)
            if snapshot.tracked_total:
                fobj.write(self.snapshot_cls_header)
                for classname in classlist:
                    data = snapshot.classes[classname].copy()
                    path = self.relative_path(self.links[classname])
                    data['cls'] = '<a href="%s">%s</a>' % (path, classname)
                    data['sum'] = pp(data['sum'])
                    data['avg'] = pp(data['avg'])
                    fobj.write(self.snapshot_cls % data)

            fobj.write('</table>')
            fobj.write('</td><td>\n')
            if snapshot.tracked_total:
                fobj.write(self.charts[snapshot])
            fobj.write('</td></tr>\n')

        fobj.write('</table>\n')
        fobj.write(self.footer)
        fobj.close()

    def create_lifetime_chart(self, classname, filename=''):
        try:
            from pylab import figure, title, xlabel, ylabel, plot, savefig
        except ImportError:
            return HtmlStats.nopylab_msg % (classname + ' lifetime')

        cnt = []
        for tobj in self.index[classname]:
            cnt.append([tobj.birth, 1])
            if tobj.death:
                cnt.append([tobj.death, -1])

        cnt.sort()
        for i in range(1, len(cnt)):
            cnt[i][1] += cnt[i - 1][1]

        x = [ t for t, c in cnt ]
        y = [ c for t, c in cnt ]
        figure()
        xlabel('Execution time [s]')
        ylabel('Instance #')
        title('%s instances' % classname)
        plot(x, y, 'o')
        savefig(filename)
        return self.chart_tag % os.path.basename(filename)

    def create_snapshot_chart(self, filename=''):
        try:
            from pylab import figure, title, xlabel, ylabel, plot, fill, legend, savefig
            import matplotlib.mlab as mlab
        except ImportError:
            return self.nopylab_msg % 'memory allocation'

        classlist = self.tracked_classes
        times = [ snapshot.timestamp for snapshot in self.snapshots ]
        base = [0] * len(self.snapshots)
        poly_labels = []
        polys = []
        for cn in classlist:
            pct = [ snapshot.classes[cn]['pct'] for snapshot in self.snapshots ]
            if pct and max(pct) > 3.0:
                sz = [ float(fp.classes[cn]['sum']) / 1048576 for fp in self.snapshots ]
                sz = [ sx + sy for sx, sy in zip(base, sz) ]
                xp, yp = mlab.poly_between(times, base, sz)
                polys.append(((xp, yp), {'label': cn}))
                poly_labels.append(cn)
                base = sz

        figure()
        title('Snapshot Memory')
        xlabel('Execution Time [s]')
        ylabel('Virtual Memory [MiB]')
        sizes = [ float(fp.asizeof_total) / 1048576 for fp in self.snapshots ]
        plot(times, sizes, 'r--', label='Total')
        sizes = [ float(fp.tracked_total) / 1048576 for fp in self.snapshots ]
        plot(times, sizes, 'b--', label='Tracked total')
        for args, kwds in polys:
            fill(*args, **kwds)

        legend(loc=2)
        savefig(filename)
        return self.chart_tag % self.relative_path(filename)

    def create_pie_chart(self, snapshot, filename=''):
        try:
            from pylab import figure, title, pie, axes, savefig
            from pylab import sum as pylab_sum
        except ImportError:
            return self.nopylab_msg % 'pie_chart'

        if not snapshot.tracked_total:
            return ''
        classlist = []
        sizelist = []
        for k, v in list(snapshot.classes.items()):
            if v['pct'] > 3.0:
                classlist.append(k)
                sizelist.append(v['sum'])

        sizelist.insert(0, snapshot.asizeof_total - pylab_sum(sizelist))
        classlist.insert(0, 'Other')
        title('Snapshot (%s) Memory Distribution' % snapshot.desc)
        figure(figsize=(8, 8))
        axes([0.1,
         0.1,
         0.8,
         0.8])
        pie(sizelist, labels=classlist)
        savefig(filename, dpi=50)
        return self.chart_tag % self.relative_path(filename)

    def create_html(self, fname, title='ClassTracker Statistics'):
        self.basedir = os.path.dirname(os.path.abspath(fname))
        self.filesdir = os.path.splitext(fname)[0] + '_files'
        if not os.path.isdir(self.filesdir):
            os.mkdir(self.filesdir)
        self.filesdir = os.path.abspath(self.filesdir)
        self.links = {}
        self.annotate()
        self.charts = {}
        fn = os.path.join(self.filesdir, 'timespace.png')
        self.charts['snapshots'] = self.create_snapshot_chart(fn)
        for fp, idx in zip(self.snapshots, list(range(len(self.snapshots)))):
            fn = os.path.join(self.filesdir, 'fp%d.png' % idx)
            self.charts[fp] = self.create_pie_chart(fp, fn)

        for cn in list(self.index.keys()):
            fn = os.path.join(self.filesdir, cn.replace('.', '_') + '-lt.png')
            self.charts[cn] = self.create_lifetime_chart(cn, fn)

        for cn in list(self.index.keys()):
            fn = os.path.join(self.filesdir, cn.replace('.', '_') + '.html')
            self.links[cn] = fn
            self.print_class_details(fn, cn)

        self.create_title_page(fname, title=title)
