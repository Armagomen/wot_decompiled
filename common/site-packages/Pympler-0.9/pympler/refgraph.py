# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/Pympler-0.9/pympler/refgraph.py
from pympler.asizeof import Asizer, named_refs
from pympler.util.stringutils import safe_repr, trunc
from pympler.util.compat import encode4pipe
from gc import get_referents
from subprocess import Popen, PIPE
from copy import copy
from sys import platform
__all__ = ['ReferenceGraph']
popen_flags = {}
if platform not in ('win32',):
    popen_flags['close_fds'] = True

class _MetaObject(object):
    __slots__ = ('size', 'id', 'type', 'str', 'group', 'cycle')

    def __init__(self):
        self.cycle = False


class _Edge(object):
    __slots__ = ('src', 'dst', 'label', 'group')

    def __init__(self, src, dst, label):
        self.src = src
        self.dst = dst
        self.label = label
        self.group = None
        return

    def __repr__(self):
        return "<%08x => %08x, '%s', %s>" % (self.src,
         self.dst,
         self.label,
         self.group)

    def __hash__(self):
        return (self.src, self.dst, self.label).__hash__()

    def __eq__(self, other):
        return self.__hash__() == other.__hash__()


class ReferenceGraph(object):

    def __init__(self, objects, reduce=False):
        self.objects = list(objects)
        self.count = len(self.objects)
        self.num_in_cycles = 'N/A'
        self.edges = None
        if reduce:
            self.num_in_cycles = self._reduce_to_cycles()
            self._reduced = self
        else:
            self._reduced = None
        self._get_edges()
        self._annotate_objects()
        return

    def _eliminate_leafs(self, graph):
        result = []
        idset = set([ id(x) for x in graph ])
        for n in graph:
            refset = set([ id(x) for x in get_referents(n) ])
            if refset.intersection(idset):
                result.append(n)

        return result

    def _reduce_to_cycles(self):
        cycles = self.objects[:]
        cnt = 0
        while cnt != len(cycles):
            cnt = len(cycles)
            cycles = self._eliminate_leafs(cycles)

        self.objects = cycles
        return len(self.objects)

    def reduce_to_cycles(self):
        if not self._reduced:
            reduced = copy(self)
            reduced.objects = self.objects[:]
            reduced.metadata = []
            reduced.edges = []
            self.num_in_cycles = reduced._reduce_to_cycles()
            reduced.num_in_cycles = self.num_in_cycles
            if self.num_in_cycles:
                reduced._get_edges()
                reduced._annotate_objects()
                for meta in reduced.metadata:
                    meta.cycle = True

            else:
                reduced = None
            self._reduced = reduced
        return self._reduced

    def _get_edges(self):
        idset = set([ id(x) for x in self.objects ])
        self.edges = set([])
        for n in self.objects:
            refset = set([ id(x) for x in get_referents(n) ])
            for ref in refset.intersection(idset):
                label = ''
                members = None
                if isinstance(n, dict):
                    members = n.items()
                if not members:
                    members = named_refs(n)
                for k, v in members:
                    if id(v) == ref:
                        label = k
                        break

                self.edges.add(_Edge(id(n), ref, label))

        return

    def _annotate_groups(self):
        g = {}
        for x in self.metadata:
            g[x.id] = x

        idx = 0
        for x in self.metadata:
            if not hasattr(x, 'group'):
                x.group = idx
                idx += 1
            neighbors = set()
            for e in self.edges:
                if e.src == x.id:
                    neighbors.add(e.dst)
                if e.dst == x.id:
                    neighbors.add(e.src)

            for nb in neighbors:
                g[nb].group = min(x.group, getattr(g[nb], 'group', idx))

        for e in self.edges:
            e.group = g[e.src].group

        self._max_group = idx

    def _filter_group(self, group):
        self.metadata = [ x for x in self.metadata if x.group == group ]
        group_set = set([ x.id for x in self.metadata ])
        self.objects = [ obj for obj in self.objects if id(obj) in group_set ]
        self.count = len(self.metadata)
        if self.metadata == []:
            return False
        self.edges = [ e for e in self.edges if e.group == group ]
        del self._max_group
        return True

    def split(self):
        self._annotate_groups()
        index = 0
        for group in range(self._max_group):
            subgraph = copy(self)
            subgraph.metadata = self.metadata[:]
            subgraph.edges = self.edges.copy()
            if subgraph._filter_group(group):
                subgraph.total_size = sum([ x.size for x in subgraph.metadata ])
                subgraph.index = index
                index += 1
                yield subgraph

    def split_and_sort(self):
        graphs = list(self.split())
        graphs.sort(key=lambda x: -len(x.metadata))
        for index, graph in enumerate(graphs):
            graph.index = index

        return graphs

    def _annotate_objects(self):
        self.metadata = []
        sizer = Asizer()
        sizes = sizer.asizesof(*self.objects)
        self.total_size = sizer.total
        for obj, sz in zip(self.objects, sizes):
            md = _MetaObject()
            md.size = sz
            md.id = id(obj)
            try:
                md.type = obj.__class__.__name__
            except (AttributeError, ReferenceError):
                md.type = type(obj).__name__

            md.str = safe_repr(obj, clip=128)
            self.metadata.append(md)

    def _get_graphviz_data(self):
        s = []
        header = '// Process this file with graphviz\n'
        s.append(header)
        s.append('digraph G {\n')
        s.append('    node [shape=box];\n')
        for md in self.metadata:
            label = trunc(md.str, 48).replace('"', "'")
            extra = ''
            if md.type == 'instancemethod':
                extra = ', color=red'
            elif md.type == 'frame':
                extra = ', color=orange'
            s.append('    "X%s" [ label = "%s\\n%s" %s ];\n' % (hex(md.id)[1:],
             label,
             md.type,
             extra))

        for e in self.edges:
            extra = ''
            if e.label == '__dict__':
                extra = ',weight=100'
            s.append('    X%s -> X%s [label="%s"%s];\n' % (hex(e.src)[1:],
             hex(e.dst)[1:],
             e.label,
             extra))

        s.append('}\n')
        return ''.join(s)

    def render(self, filename, cmd='dot', format='ps', unflatten=False):
        if self.objects == []:
            return False
        else:
            data = self._get_graphviz_data()
            options = ('-Nfontsize=10', '-Efontsize=10', '-Nstyle=filled', '-Nfillcolor=#E5EDB8', '-Ncolor=#CCCCCC')
            cmdline = (cmd,
             '-T%s' % format,
             '-o',
             filename) + options
            if unflatten:
                p1 = Popen(('unflatten', '-l7'), stdin=PIPE, stdout=PIPE, **popen_flags)
                p2 = Popen(cmdline, stdin=p1.stdout, **popen_flags)
                p1.communicate(encode4pipe(data))
                p2.communicate()
                return p2.returncode == 0
            p = Popen(cmdline, stdin=PIPE, **popen_flags)
            p.communicate(encode4pipe(data))
            return p.returncode == 0

    def write_graph(self, filename):
        f = open(filename, 'w')
        f.write(self._get_graphviz_data())
        f.close()
