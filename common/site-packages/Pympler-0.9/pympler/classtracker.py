# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/Pympler-0.9/pympler/classtracker.py
from collections import defaultdict
from functools import partial
from inspect import stack, isclass
from threading import Thread, Lock
from time import sleep, time
from weakref import ref as weakref_ref
from pympler.classtracker_stats import ConsoleStats
from pympler.util.compat import instancemethod
from pympler.util.stringutils import safe_repr
import pympler.asizeof as asizeof
import pympler.process
__all__ = ['ClassTracker']
_local_start = time()

class _ClassObserver(object):
    __slots__ = ('init', 'name', 'detail', 'keep', 'trace')

    def __init__(self, init, name, detail, keep, trace):
        self.init = init
        self.name = name
        self.detail = detail
        self.keep = keep
        self.trace = trace

    def modify(self, name, detail, keep, trace):
        self.name = name
        self.detail = detail
        self.keep = keep
        self.trace = trace


def _get_time():
    return time() - _local_start


class TrackedObject(object):
    __slots__ = ('ref', 'id', 'repr', 'name', 'birth', 'death', 'trace', 'snapshots', '_resolution_level', '__dict__')

    def __init__(self, instance, name, resolution_level=0, trace=False, on_delete=None):
        self.ref = weakref_ref(instance, self.finalize)
        self.id = id(instance)
        self.repr = ''
        self.name = name
        self.birth = _get_time()
        self.death = None
        self._resolution_level = resolution_level
        self.trace = None
        if trace:
            self._save_trace()
        initial_size = asizeof.basicsize(instance) or 0
        size = asizeof.Asized(initial_size, initial_size)
        self.snapshots = [(self.birth, size)]
        self.on_delete = on_delete
        return

    def __getstate__(self):
        state = {}
        for name in getattr(TrackedObject, '__slots__', ()):
            if hasattr(self, name) and name not in ('ref', '__dict__'):
                state[name] = getattr(self, name)

        return state

    def __setstate__(self, state):
        for key, value in list(state.items()):
            setattr(self, key, value)

    def _save_trace(self):
        stack_trace = stack()
        try:
            self.trace = []
            for frm in stack_trace[5:]:
                self.trace.insert(0, frm[1:])

        finally:
            del stack_trace

    def track_size(self, ts, sizer):
        obj = self.ref()
        self.snapshots.append((ts, sizer.asized(obj, detail=self._resolution_level)))
        if obj is not None:
            self.repr = safe_repr(obj, clip=128)
        return

    def get_max_size(self):
        return max([ s.size for _, s in self.snapshots ])

    def get_size_at_time(self, timestamp):
        size = 0
        for t, s in self.snapshots:
            if t == timestamp:
                size = s.size

        return size

    def set_resolution_level(self, resolution_level):
        self._resolution_level = resolution_level

    def finalize(self, ref):
        try:
            self.death = _get_time()
            if self.on_delete:
                self.on_delete()
        except Exception:
            pass


def track_object_creation(time_series):
    num_instances = time_series[-1][1] if time_series else 0
    time_series.append((_get_time(), num_instances + 1))


def track_object_deletion(time_series):
    num_instances = time_series[-1][1]
    time_series.append((_get_time(), num_instances - 1))


class PeriodicThread(Thread):

    def __init__(self, tracker, interval, *args, **kwargs):
        self.interval = interval
        self.tracker = tracker
        self.stop = False
        super(PeriodicThread, self).__init__(*args, **kwargs)

    def run(self):
        self.stop = False
        while not self.stop:
            self.tracker.create_snapshot()
            sleep(self.interval)


class Snapshot(object):

    def __init__(self):
        self.tracked_total = 0
        self.asizeof_total = 0
        self.overhead = 0
        self.timestamp = None
        self.system_total = None
        self.desc = None
        return

    @property
    def total(self):
        if self.system_total.available:
            return self.system_total.vsz
        elif self.asizeof_total:
            return self.asizeof_total
        else:
            return self.tracked_total

    @property
    def label(self):
        return '%.3fs' % self.timestamp if not self.desc else '%s (%.3fs)' % (self.desc, self.timestamp)


class ClassTracker(object):

    def __init__(self, stream=None):
        self.index = defaultdict(list)
        self.objects = {}
        self.snapshots = []
        self.history = defaultdict(list)
        self._keepalive = []
        self._observers = {}
        self._periodic_thread = None
        self._stream = stream
        return

    @property
    def stats(self):
        return ConsoleStats(tracker=self, stream=self._stream)

    def _tracker(self, _observer_, _self_, *args, **kwds):
        self.track_object(_self_, name=_observer_.name, resolution_level=_observer_.detail, keep=_observer_.keep, trace=_observer_.trace)
        _observer_.init(_self_, *args, **kwds)

    def _inject_constructor(self, cls, func, name, resolution_level, keep, trace):
        try:
            constructor = cls.__init__
        except AttributeError:

            def constructor(self, *_args, **_kwargs):
                pass

        observer = _ClassObserver(constructor, name, resolution_level, keep, trace)
        self._observers[cls] = observer

        def new_constructor(*args, **kwargs):
            return func(observer, *args, **kwargs)

        cls.__init__ = instancemethod(new_constructor, None, cls)
        return

    def _is_tracked(self, cls):
        return cls in self._observers

    def _track_modify(self, cls, name, detail, keep, trace):
        self._observers[cls].modify(name, detail, keep, trace)

    def _restore_constructor(self, cls):
        cls.__init__ = self._observers[cls].init
        del self._observers[cls]

    def track_change(self, instance, resolution_level=0):
        tobj = self.objects[id(instance)]
        tobj.set_resolution_level(resolution_level)

    def track_object(self, instance, name=None, resolution_level=0, keep=False, trace=False):
        if id(instance) in self.objects and self.objects[id(instance)].ref() is not None:
            return
        else:
            name = name if name else instance.__class__.__name__
            track_object_creation(self.history[name])
            on_delete = partial(track_object_deletion, self.history[name])
            tobj = TrackedObject(instance, name, resolution_level=resolution_level, trace=trace, on_delete=on_delete)
            self.index[name].append(tobj)
            self.objects[id(instance)] = tobj
            if keep:
                self._keepalive.append(instance)
            return

    def track_class(self, cls, name=None, resolution_level=0, keep=False, trace=False):
        if not isclass(cls):
            raise TypeError('only class objects can be tracked')
        if name is None:
            name = cls.__module__ + '.' + cls.__name__
        if self._is_tracked(cls):
            self._track_modify(cls, name, resolution_level, keep, trace)
        else:
            self._inject_constructor(cls, self._tracker, name, resolution_level, keep, trace)
        return

    def detach_class(self, cls):
        self._restore_constructor(cls)

    def detach_all_classes(self):
        classes = list(self._observers.keys())
        for cls in classes:
            self.detach_class(cls)

    def detach_all(self):
        self.detach_all_classes()
        self.objects.clear()
        self.index.clear()
        self._keepalive[:] = []

    def clear(self):
        self.detach_all()
        self.snapshots[:] = []

    def close(self):
        self.detach_all_classes()

    def start_periodic_snapshots(self, interval=1.0):
        if not self._periodic_thread:
            self._periodic_thread = PeriodicThread(self, interval, name='BackgroundMonitor')
            self._periodic_thread.setDaemon(True)
            self._periodic_thread.start()
        else:
            self._periodic_thread.interval = interval

    def stop_periodic_snapshots(self):
        if self._periodic_thread and self._periodic_thread.is_alive():
            self._periodic_thread.stop = True
            self._periodic_thread.join()
            self._periodic_thread = None
        return

    snapshot_lock = Lock()

    def create_snapshot(self, description='', compute_total=False):
        try:
            self.snapshot_lock.acquire()
            timestamp = _get_time()
            sizer = asizeof.Asizer()
            objs = [ tobj.ref() for tobj in list(self.objects.values()) ]
            sizer.exclude_refs(*objs)
            tracked_objects = list(self.objects.values())
            tracked_objects.sort(key=lambda x: x.birth)
            for tobj in tracked_objects:
                tobj.track_size(timestamp, sizer)

            snapshot = Snapshot()
            snapshot.timestamp = timestamp
            snapshot.tracked_total = sizer.total
            if compute_total:
                snapshot.asizeof_total = asizeof.asizeof(all=True, code=True)
            snapshot.system_total = pympler.process.ProcessMemoryInfo()
            snapshot.desc = str(description)
            snapshot.overhead = 0
            if snapshot.tracked_total:
                snapshot.overhead = sizer.asizeof(self)
                if snapshot.asizeof_total:
                    snapshot.asizeof_total -= snapshot.overhead
            self.snapshots.append(snapshot)
        finally:
            self.snapshot_lock.release()
