# Python bytecode 2.7 (decompiled from Python 2.7)
# Embedded file name: scripts/common/site-packages/future-1.0.0/past/translation/__init__.py
import sys
if sys.version_info >= (3, 6):
    import importlib as imp
else:
    import imp
import logging
import os
import copy
from lib2to3.pgen2.parse import ParseError
from lib2to3.refactor import RefactoringTool
from libfuturize import fixes
try:
    from importlib.machinery import PathFinder, SourceFileLoader
except ImportError:
    PathFinder = None
    SourceFileLoader = object

if sys.version_info[:2] < (3, 4):
    import imp
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
myfixes = list(fixes.libfuturize_fix_names_stage1) + list(fixes.lib2to3_fix_names_stage1) + list(fixes.libfuturize_fix_names_stage2) + list(fixes.lib2to3_fix_names_stage2)
py2_detect_fixers = ['lib2to3.fixes.fix_apply',
 'lib2to3.fixes.fix_except',
 'lib2to3.fixes.fix_execfile',
 'lib2to3.fixes.fix_exitfunc',
 'lib2to3.fixes.fix_funcattrs',
 'lib2to3.fixes.fix_filter',
 'lib2to3.fixes.fix_has_key',
 'lib2to3.fixes.fix_idioms',
 'lib2to3.fixes.fix_import',
 'lib2to3.fixes.fix_intern',
 'lib2to3.fixes.fix_isinstance',
 'lib2to3.fixes.fix_methodattrs',
 'lib2to3.fixes.fix_ne',
 'lib2to3.fixes.fix_numliterals',
 'lib2to3.fixes.fix_paren',
 'lib2to3.fixes.fix_print',
 'lib2to3.fixes.fix_raise',
 'lib2to3.fixes.fix_renames',
 'lib2to3.fixes.fix_reduce',
 'lib2to3.fixes.fix_repr',
 'lib2to3.fixes.fix_standarderror',
 'lib2to3.fixes.fix_sys_exc',
 'lib2to3.fixes.fix_throw',
 'lib2to3.fixes.fix_tuple_params',
 'lib2to3.fixes.fix_types',
 'lib2to3.fixes.fix_ws_comma',
 'lib2to3.fixes.fix_xreadlines',
 'lib2to3.fixes.fix_basestring',
 'lib2to3.fixes.fix_exec',
 'lib2to3.fixes.fix_getcwdu',
 'lib2to3.fixes.fix_long',
 'lib2to3.fixes.fix_next',
 'lib2to3.fixes.fix_nonzero',
 'lib2to3.fixes.fix_raw_input',
 'lib2to3.fixes.fix_xrange']

class RTs:
    _rt = None
    _rtp = None
    _rt_py2_detect = None
    _rtp_py2_detect = None

    @staticmethod
    def setup():
        if None in [RTs._rt, RTs._rtp]:
            RTs._rt = RefactoringTool(myfixes)
            RTs._rtp = RefactoringTool(myfixes, {'print_function': True})
        return

    @staticmethod
    def setup_detect_python2():
        if None in [RTs._rt_py2_detect, RTs._rtp_py2_detect]:
            RTs._rt_py2_detect = RefactoringTool(py2_detect_fixers)
            RTs._rtp_py2_detect = RefactoringTool(py2_detect_fixers, {'print_function': True})
        return


def splitall(path):
    allparts = []
    while True:
        parts = os.path.split(path)
        if parts[0] == path:
            allparts.insert(0, parts[0])
            break
        if parts[1] == path:
            allparts.insert(0, parts[1])
            break
        path = parts[0]
        allparts.insert(0, parts[1])

    return allparts


def common_substring(s1, s2):
    chunks = []
    path1 = splitall(s1)
    path2 = splitall(s2)
    for dir1, dir2 in zip(path1, path2):
        if dir1 != dir2:
            break
        chunks.append(dir1)

    return os.path.join(*chunks)


def detect_python2(source, pathname):
    RTs.setup_detect_python2()
    try:
        tree = RTs._rt_py2_detect.refactor_string(source, pathname)
    except ParseError as e:
        if e.msg != 'bad input' or e.value != '=':
            raise
        tree = RTs._rtp.refactor_string(source, pathname)

    if source != str(tree)[:-1]:
        logger.debug('Detected Python 2 code: {0}'.format(pathname))
        return True
    else:
        logger.debug('Detected Python 3 code: {0}'.format(pathname))
        return False


def transform(source, pathname):
    RTs.setup()
    source += '\n'
    try:
        tree = RTs._rt.refactor_string(source, pathname)
    except ParseError as e:
        if e.msg != 'bad input' or e.value != '=':
            raise
        tree = RTs._rtp.refactor_string(source, pathname)

    return str(tree)[:-1]


class PastSourceFileLoader(SourceFileLoader):
    exclude_paths = []
    include_paths = []

    def _convert_needed(self):
        fullname = self.name
        if any((fullname.startswith(path) for path in self.exclude_paths)):
            convert = False
        elif any((fullname.startswith(path) for path in self.include_paths)):
            convert = True
        else:
            convert = False
        return convert

    def _exec_transformed_module(self, module):
        source = self.get_source(self.name)
        pathname = self.path
        if detect_python2(source, pathname):
            source = transform(source, pathname)
        code = compile(source, pathname, 'exec')
        exec code in module.__dict__

    def load_module(self, fullname):
        logger.debug('Running load_module for %s', fullname)
        if fullname in sys.modules:
            mod = sys.modules[fullname]
        elif self._convert_needed():
            logger.debug('Autoconverting %s', fullname)
            mod = imp.new_module(fullname)
            sys.modules[fullname] = mod
            mod.__file__ = self.path
            mod.__loader__ = self
            if self.is_package(fullname):
                mod.__path__ = []
                mod.__package__ = fullname
            else:
                mod.__package__ = fullname.rpartition('.')[0]
            self._exec_transformed_module(mod)
        else:
            mod = super().load_module(fullname)
        return mod

    def exec_module(self, module):
        logger.debug('Running exec_module for %s', module)
        if self._convert_needed():
            logger.debug('Autoconverting %s', self.name)
            self._exec_transformed_module(module)
        else:
            super().exec_module(module)


class Py2Fixer(object):
    PY2FIXER = True

    def __init__(self):
        self.found = None
        self.base_exclude_paths = ['future', 'past']
        self.exclude_paths = copy.copy(self.base_exclude_paths)
        self.include_paths = []
        return

    def include(self, paths):
        self.include_paths += paths

    def exclude(self, paths):
        self.exclude_paths += paths

    def find_module(self, fullname, path=None):
        logger.debug('Running find_module: (%s, %s)', fullname, path)
        loader = PathFinder.find_module(fullname, path)
        if not loader:
            logger.debug('Py2Fixer could not find %s', fullname)
            return None
        else:
            loader.__class__ = PastSourceFileLoader
            loader.exclude_paths = self.exclude_paths
            loader.include_paths = self.include_paths
            return loader

    def find_spec(self, fullname, path=None, target=None):
        logger.debug('Running find_spec: (%s, %s, %s)', fullname, path, target)
        spec = PathFinder.find_spec(fullname, path, target)
        if not spec:
            logger.debug('Py2Fixer could not find %s', fullname)
            return None
        else:
            spec.loader.__class__ = PastSourceFileLoader
            spec.loader.exclude_paths = self.exclude_paths
            spec.loader.include_paths = self.include_paths
            return spec


_hook = Py2Fixer()

def install_hooks(include_paths=(), exclude_paths=()):
    if isinstance(include_paths, str):
        include_paths = (include_paths,)
    if isinstance(exclude_paths, str):
        exclude_paths = (exclude_paths,)
    _hook.include(include_paths)
    _hook.exclude(exclude_paths)
    enable = sys.version_info[0] >= 3
    if enable and _hook not in sys.meta_path:
        sys.meta_path.insert(0, _hook)


def remove_hooks():
    if _hook in sys.meta_path:
        sys.meta_path.remove(_hook)


def detect_hooks():
    return _hook in sys.meta_path


class hooks(object):

    def __enter__(self):
        self.hooks_were_installed = detect_hooks()
        install_hooks()
        return self

    def __exit__(self, *args):
        if not self.hooks_were_installed:
            remove_hooks()


class suspend_hooks(object):

    def __enter__(self):
        self.hooks_were_installed = detect_hooks()
        remove_hooks()
        return self

    def __exit__(self, *args):
        if self.hooks_were_installed:
            install_hooks()


autotranslate = install_hooks
